# 实验 2：内存管理

## 介绍

在本实验中，您将为您的操作系统编写内存管理代码。内存管理有两个组成部分。

第一个组件是内核的物理内存分配器，以便内核可以分配内存并稍后释放它。您的分配器将以 4096 字节为单位运行，称为 *pages*。您的任务是维护数据结构，记录哪些物理页面是空闲的，哪些已分配，以及有多少进程正在共享每个分配的页面。您还将编写分配和释放内存页的例程。

内存管理的第二个组件是*虚拟内存*，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86 硬件的内存管理单元 (MMU) 在指令使用内存时执行映射，查询一组页表。您将根据我们提供的规范修改 JOS 以设置 MMU 的页表。

### 入门

在这个和以后的实验中，您将逐步构建您的内核。我们还将为您提供一些额外的来源。要获取该源，请使用 Git 提交自上交实验室 1 以来所做的更改（如果有），获取课程存储库的最新版本，然后基于我们的 lab2 分支`origin/lab2`创建一个名为`lab2`的本地分支：``

```
cd ~/6.828/lab
add git
git pull
已经是最新的。
git checkout -b lab2 origin/lab2
分支 lab2 设置为跟踪远程分支 refs/remotes/origin/lab2。
切换到新分支“lab2”
```

git checkout -b上面显示 的命令实际上做了两件事：首先创建一个基于课程人员提供的`origin/lab2`分支的本地分支`lab2`，其次，它更改您的`lab` 目录的内容以反映存储在`lab2`上的`文件`分支。Git 允许使用 切换现有分支，但您应该在切换到另一个分支之前在一个分支上提交任何未完成的更改。 ``````git checkout *branch-name*

您现在需要将您在`lab1` 分支中所做的更改合并到`lab2`分支中，如下所示：

```
雅典娜% git merge lab1
通过递归进行合并。
 内核/kdebug.c | 11 +++++++++--
 内核/监视器.c | 19 +++++++++++++++++++++
 lib/printfmt.c | 7 +++----
 更改了 3 个文件，插入了 31 个（+），删除了 6 个（-）
雅典娜% 
```

在某些情况下，Git 可能无法弄清楚如何将您的更改与新的实验室作业合并（例如，如果您修改了在第二个实验室作业中更改的某些代码）。在这种情况下，该git merge命令会告诉您哪些文件有*冲突*，您应该首先解决冲突（通过编辑相关文件），然后使用git commit -a.

实验 2 包含以下新源文件，您应该浏览这些文件：

- `公司/内存布局.h`
- `内核/pmap.c`
- `字距/pmap.h`
- `内核/kclock.h`
- `内核/kclock.c`

`memlayout.h`描述了必须通过修改`pmap.c`来实现的虚拟地址空间的布局。 `memlayout.h`和`pmap.h`定义了`PageInfo` 用于跟踪哪些物理内存页面空闲的结构。 `kclock.c`和`kclock.h` 操作 PC 的电池供电时钟和 CMOS RAM 硬件，其中 BIOS 记录 PC 包含的物理内存量等。`pmap.c 中`的代码需要读取这个设备硬件，以便计算出有多少物理内存，但这部分代码是为你完成的：你不需要知道 CMOS 硬件如何工作的细节。

请特别注意`memlayout.h`和`pmap.h`，因为本实验要求您使用并理解它们包含的许多定义。您可能还想查看`inc/mmu.h`，因为它还包含许多对本实验有用的定义。

在开始实验之前，不要忘记add -f 6.828获取 6.828 版本的 QEMU。

### 实验室要求

在本实验和后续实验中，完成实验中描述的所有常规练习和*至少一个*挑战题。（当然，有些挑战问题比其他问题更具挑战性！）此外，写下对实验室中提出的问题的简短回答，并简短（例如，一两段）描述您为解决所选挑战问题所做的工作。如果你实现了多个挑战问题，你只需要在文章中描述其中一个，当然欢迎你做更多。在提交您的工作之前，将`撰写` 的内容放在`实验室`目录顶层的名为`answers-lab2.txt`的文件中。

### 上交程序

当您准备好提交实验室代码并撰写文章时，将您的`answers-lab2.txt`添加到 Git 存储库，提交您的更改，然后运行make handin.

```
雅典娜%git add answers-lab2.txt
雅典娜%git commit -am "my answer to lab2"
[lab2 a823de9] 我对lab2的回答
 4 个文件更改，87 个插入（+），10 个删除（-）
雅典娜% make handin
```



和以前一样，我们将使用分级程序对您的解决方案进行分级。您可以make grade在`lab`目录中运行以使用分级程序测试您的内核。您可以更改任何内核源文件和头文件以完成实验，但不用说，您不得更改或以其他方式破坏评分代码。

## 第 1 部分：物理页面管理

操作系统必须跟踪物理 RAM 的哪些部分是空闲的，哪些是当前正在使用的。JOS 以*页面粒度*管理 PC 的物理内存， 以便它可以使用 MMU 来映射和保护每块分配的内存。

您现在将编写物理页面分配器。它通过一个`struct PageInfo`对象链接列表来跟踪哪些页面是空闲的（与 xv6 不同的是，它们*没有*嵌入到空闲页面本身中），每个页面对应一个物理页面。您需要先编写物理页分配器，然后才能编写其余的虚拟内存实现，因为页表管理代码需要分配物理内存来存储页表。

### **Exercise1**

在文件`kern/pmap.c 中`，您必须为以下函数实现代码（可能按照给定的顺序）。

```
boot_alloc()`
`mem_init()`（仅限于调用`check_page_free_list(1)`）
`page_init()`
`page_alloc()`
`page_free()
```

`check_page_free_list()`并 `check_page_alloc()`测试您的物理页面分配器。您应该启动 JOS 并查看是否`check_page_alloc()` 报告成功。修复您的代码，使其通过。您可能会发现添加您自己的`assert()`s 以验证您的假设是否正确很有帮助。

该实验室以及所有 6.828 实验室将要求您进行一些侦查工作，以确定您需要做什么。此作业并未描述您必须添加到 JOS 的代码的所有细节。在您必须修改的 JOS 源代码部分中查找注释；这些注释通常包含规范和提示。您还需要查看 JOS 的相关部分、Intel 手册以及 6.004 或 6.033 注释。

## 第 2 部分：虚拟内存

在做任何其他事情之前，先熟悉 x86 的保护模式内存管理架构：即*分段*和*页面转换*。

### **Exercise2** 

查看[ Intel 80386 参考手册的](https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm)第 5 章和第 6 章 ，如果您还没有这样做的话。仔细阅读有关页面转换和基于页面的保护的部分（5.2 和 6.4）。我们建议您还浏览有关细分的部分；虽然 JOS 使用分页硬件进行虚拟内存和保护，但不能在 x86 上禁用段转换和基于段的保护，因此您需要对其有基本的了解。

### 虚拟、线性和物理地址

在 x86 术语中，*虚拟地址* 由段选择器和段内的偏移量组成。一个*线性地址* 是段转换之后，但网页翻译之前，你会得到什么。一个*物理地址* 是什么，你在段和网页翻译，什么最终走出硬件总线到您的RAM后，终于搞定了。

```
           选择器 +--------------+ +-----------+          ---------->| | | |                     | 细分 | | 分页| 软件 | |-------->| |-----------> 内存            偏移| 机制 | | 机制 |          ---------->| | | |                     +--------------+ +-----------+            虚拟线性物理 
```

AC 指针是虚拟地址的“偏移量”组件。在`boot/boot.S 中`，我们安装了一个全局描述符表 (GDT)，它通过将所有段基地址设置为 0 并将限制设置为 来有效地禁用段转换`0xffffffff`。因此“选择器”不起作用，线性地址总是等于虚拟地址的偏移量。在实验 3 中，我们将不得不与分段进行更多交互以设置权限级别，但是对于记忆翻译，我们可以在整个 JOS 实验中忽略分段，而只关注页面翻译。

回想一下，在实验 1 的第 3 部分中，我们安装了一个简单的页表，以便内核可以在其链接地址 0xf0100000 处运行，即使它实际上加载到 ROM BIOS 上方 0x00100000 处的物理内存中。这个页表只映射了 4MB 的内存。在本实验中您要为 JOS 设置的虚拟地址空间布局中，我们将扩展它以映射从虚拟地址 0xf0000000 开始的前 256MB 物理内存，并映射虚拟地址空间的许多其他区域。

**Exercise3** 

虽然 GDB 只能通过虚拟地址访问 QEMU 的内存，但在设置虚拟内存时能够检查物理内存通常很有用。查看实验室工具指南中的 QEMU[监视器命令](https://pdos.csail.mit.edu/6.828/2017/labguide.html#qemu)，尤其是 `xp`命令，它可以让您检查物理内存。要访问 QEMU 监视器，请Ctrl-a c在终端中按下（相同的绑定返回到串行控制台）。

使用xpQEMU 监视器中的x命令和 GDB 中的 命令检查相应物理和虚拟地址处的内存，并确保您看到相同的数据。

我们的 QEMU 补丁版本提供了一个info pg 可能也很有用的命令：它显示了当前页表的紧凑但详细的表示，包括所有映射的内存范围、权限和标志。Stock QEMU 还提供了一个info mem命令，该命令显示映射了哪些虚拟地址范围以及具有哪些权限的概述。

从在 CPU 上执行的代码来看，一旦我们处于保护模式（我们首先在`boot/boot.S 中输入`），就无法直接使用线性或物理地址。 *所有*内存引用都被解释为虚拟地址并由 MMU 翻译，这意味着 C 中的所有指针都是虚拟地址。

JOS 内核通常需要将地址作为不透明值或整数进行操作，而不是取消引用它们，例如在物理内存分配器中。有时这些是虚拟地址，有时它们是物理地址。为了帮助记录代码，JOS 源区分了两种情况：类型`uintptr_t`表示不透明的虚拟地址，和`physaddr_t`表示物理地址。这两种类型实际上只是 32 位整数 ( `uint32_t`) 的同义词，因此编译器不会阻止您将一种类型分配给另一种类型！由于它们是整数类型（不是指针），如果您尝试取消引用它们，编译器*会*抱怨。

JOS 内核可以`uintptr_t`通过首先将其转换为指针类型来取消引用 a 。相比之下，内核无法合理地取消引用物理地址，因为 MMU 会转换所有内存引用。如果您将 a`physaddr_t`转换为指针并取消引用它，您可能能够加载并存储到结果地址（硬件会将其解释为虚拟地址），但您可能无法获得您想要的内存位置。

总结一下：

| C型          | 地址类型 |
| ------------ | -------- |
| `T*`         | 虚拟的   |
| `uintptr_t`  | 虚拟的   |
| `physaddr_t` | 身体的   |



**题**

1. 假设下面的 JOS 内核代码是正确的，变量应该是什么类型

   ```
   x
   ```

   ，

   ```
   uintptr_t
   ```

   或者 

   ```
   physaddr_t
   ```

   ？

   ```
   	神秘_t x;
   	char* value = return_a_pointer();
   	*值= 10；
   	x = ( secret_t ) 值；
   ```

JOS 内核有时需要读取或修改它只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核无法绕过虚拟地址转换，因此无法直接加载和存储到物理地址。JOS 重新映射从物理地址 0 开始到虚拟地址 0xf0000000 的所有物理内存的原因之一是帮助内核读取和写入它只知道物理地址的内存。为了将一个物理地址转换成内核可以实际读写的虚拟地址，内核必须在物理地址上加上0xf0000000，才能在重映射的区域中找到其对应的虚拟地址。你应该使用`KADDR(pa)` 做那个加法。

给定存储内核数据结构的内存的虚拟地址，JOS 内核有时也需要能够找到物理地址。内核全局变量和分配的内存 `boot_alloc()`位于加载内核的区域，从 0xf0000000 开始，也就是我们映射所有物理内存的区域。因此，要将这个区域中的虚拟地址转换为物理地址，内核可以简单地减去 0xf0000000。你应该`PADDR(va)` 用来做那个减法。

### 引用计数

在未来的实验中，您通常会将相同的物理页面同时映射到多个虚拟地址（或多个环境的地址空间中）。您将在物理页面对应的`pp_ref`字段中记录对每个物理页面的引用次数`struct PageInfo`。当一个物理页面的这个计数变为零时，该页面可以被释放，因为它不再被使用。一般来说，这个计数应该等于物理页在所有页表中出现*在下面 `UTOP`*的次数（上面的映射 `UTOP`大部分在启动时由内核设置，永远不应该被释放，所以没有必要对它们进行引用计数）。我们还将使用它来跟踪我们保留的指向页目录页的指针的数量，进而跟踪页目录对页表页的引用数量。

使用`page_alloc`时要小心。它返回的页面将始终具有 0 的引用计数，因此，只要您对返回的页面进行了某些操作（例如将其插入到页表中），就应该增加`pp_ref`。有时这由其他函数处理（例如，`page_insert`），有时调用`page_alloc`的函数必须直接执行此操作。

### 页表管理

现在您将编写一组例程来管理页表：插入和删除线性到物理映射，以及在需要时创建页表页。

### **Exercise4** 

在文件`kern/pmap.c 中`，您必须实现以下函数的代码。

```
        pgdir_walk()
        boot_map_region()
        page_lookup()
        page_remove()
        页插入（）	
```

`check_page()`，调用 from `mem_init()`，测试您的页表管理例程。在继续之前，您应该确保它报告成功。

## 第 3 部分：内核地址空间

JOS 将处理器的 32 位线性地址空间分为两部分。我们将在实验 3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。分割线由符号定义有些武断`ULIM`在`INC / memlayout.h`，保留约256MB的虚拟地址空间是内核。这就解释了为什么我们需要在实验室 1 中给内核一个如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境。

您会发现参考`inc/memlayout.h 中`的 JOS 内存布局图 对本部分和后续实验`很有帮助`。

### 权限和故障隔离

由于内核和用户内存都存在于每个环境的地址空间中，我们将不得不在 x86 页表中使用权限位来允许用户代码仅访问地址空间的用户部分。否则用户代码中的错误可能会覆盖内核数据，导致崩溃或更微妙的故障；用户代码也可能窃取其他环境的私人数据。请注意，可写权限位 ( `PTE_W` ) 会影响用户和内核代码！

用户环境对上面的任何内存都没有权限`ULIM`，而内核将能够读写这块内存。对于地址范围 `[UTOP,ULIM)`，内核和用户环境都拥有相同的权限：可以读但不能写这个地址范围。该地址范围用于向用户环境公开某些只读的内核数据结构。最后，下面的地址空间 `UTOP`是供用户环境使用的；用户环境将设置访问此内存的权限。

### 初始化内核地址空间

现在您将设置上面的地址空间`UTOP`：地址空间的内核部分。 `inc/memlayout.h`显示您应该使用的布局。您将使用刚刚编写的函数来设置适当的线性到物理映射。

### **Exercise5** 

在`mem_init()`调用 之后填写缺少的代码`check_page()`。

您的代码现在应该通过`check_kern_pgdir()` 和`check_page_installed_pgdir()`检查。



**题**

1. 页面目录中的哪些条目（行）此时已被填充？它们映射哪些地址以及指向何处？换句话说，尽可能多地填写这张表：

   | 入口 | 基本虚拟地址 | 指向（逻辑上）：      |
   | ---- | ------------ | --------------------- |
   | 1023 | ?            | 前 4MB 物理内存的页表 |
   | 1022 | ?            | ?                     |
   | .    | ?            | ?                     |
   | .    | ?            | ?                     |
   | .    | ?            | ?                     |
   | 2    | 0x00800000   | ?                     |
   | 1    | 0x00400000   | ?                     |
   | 0    | 0x00000000   | [见下一个问题]        |

2. 我们已经将内核和用户环境放在相同的地址空间中。为什么用户程序不能读写内核内存？什么具体机制保护内核内存？

3. 此操作系统可以支持的最大物理内存量是多少？为什么？

4. 如果我们实际上拥有最大数量的物理内存，那么管理内存有多少空间开销？这个开销是如何分解的？

5. 重新访问`kern/entry.S`和 `kern/entrypgdir.c 中`的页表设置。在我们打开分页后，EIP 仍然是一个很小的数字（略高于 1MB）。我们在什么时候过渡到在 KERNBASE 之上的 EIP 上运行？是什么让我们可以在启用分页和开始在高于 KERNBASE 的 EIP 上运行之间继续以低 EIP 执行？为什么需要这种转变？

*挑战！* 我们使用了许多物理页来保存 KERNBASE 映射的页表。使用页目录条目中的 PTE_PS（“页大小”）位执行更节省空间的工作。原始 80386*不*支持此位，但在更新的 x86 处理器上支持。因此，您必须参考 [当前英特尔手册的第 3 卷](https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf)。确保您将内核设计为仅在支持它的处理器上使用此优化！

*挑战！* 使用以下命令扩展 JOS 内核监视器：

- 以有用且易于阅读的格式显示适用于当前活动地址空间中特定范围的虚拟/线性地址的所有物理页面映射（或缺少）。例如，您可以输入`“showmappings 0x3000 0x5000”` 以显示物理页面映射以及适用于虚拟地址 0x3000、0x4000 和 0x5000 处的页面的相应权限位。
- 显式设置、清除或更改当前地址空间中任何映射的权限。
- 转储给定虚拟或物理地址范围的内存范围的内容。当范围跨越页面边界时，确保转储代码的行为正确！
- 执行您认为稍后可能对调试内核有用的任何其他操作。（很有可能是这样！）

### 地址空间布局替代方案

我们在 JOS 中使用的地址空间布局并不是唯一可能的。操作系统可能会将内核映射到低线性地址，而将线性地址空间的*高*部分留给用户进程。然而，x86 内核通常不采用这种方法，因为 x86 的一种向后兼容模式，称为*虚拟 8086 模式*，在处理器中“硬连线”以使用线性地址空间的底部，因此不能如果内核映射到那里，则根本不会使用。

甚至有可能将内核设计为不必为自己保留处理器线性或虚拟地址空间的*任何*固定部分，而是有效地允许用户级进程不受限制地使用*整个*4GB虚拟地址空间 - 同时仍然完全保护内核免受这些进程的影响，并保护不同的进程相互之间！

### *附加题1* 

概述如何设计内核以允许用户环境不受限制地使用完整的 4GB 虚拟和线性地址空间。提示：该技术有时被称为“*跟随弹跳内核”*。在您的设计中，一定要准确说明处理器在内核模式和用户模式之间转换时会发生什么，以及内核如何完成这种转换。还描述内核将如何访问该方案中的物理内存和 I/O 设备，以及内核将如何在系统调用等期间访问用户环境的虚拟地址空间。最后，从灵活性、性能、内核复杂度和其他你能想到的因素考虑和描述这种方案的优缺点。



### *附加题2* 

由于我们的 JOS 内核的内存管理系统仅在页面粒度上分配和释放内存，因此我们没有任何可与我们可以在内核中使用的通用`malloc`/`free`设施相媲美的东西。如果我们想要支持某些类型的 I/O 设备需要大于 4KB 的*物理连续*缓冲区，或者如果我们希望用户级环境（而不仅仅是内核）能够分配和映射，这可能是一个问题4MB*超级页面可* 实现最大处理器效率。（参见之前关于 PTE_PS 的挑战问题。）

概括内核的内存分配系统以支持各种 2 的幂分配单元大小的页面，从 4KB 到您选择的某个合理的最大值。确保您有某种方法可以根据需要将较大的分配单元划分为较小的分配单元，并在可能的情况下将多个小分配单元合并回较大的单元。想想在这样的系统中可能出现的问题。

**这样就完成了实验室。** 确保您通过了所有make grade测试，并且不要忘记在`answers-lab2.txt 中`写下您的问题答案和挑战练习解决方案 `的描述`。提交你的修改（包括添加`答案-lab2.txt`）和类型make handin的`实验室`在实验室目录下的手。

## 回答问题汇总

### Exercise1

### Exercise2

### Exercise3

### Exercise4

### Exercise5

### 附加题1

### 附加题2

## 关键文件代码注释

