L6：虚拟内存
==

## 虚拟内存概述

* 今天的问题：
  假设shell有一个错误：有时它会写入一个随机内存地址，我们如何防止它破坏内核？以及破坏其他进程？
  
* 我们想要隔离的地址空间
  1.每个进程都有自己的内存
  2.它可以读写自己的内存
  3.它不能读或写任何其他东西
  想一想： 
    如何在一个物理内存上复用多个内存？
	同时保持内存之间的隔离

* xv6 和 JOS 主要使用 x86 的分页硬件来实现隔离
  
* 分页为寻址提供了一个间接级别
  CPU -> MMU -> RAM
      VA PA
  s/w 只能 ld/st 到虚拟地址，而不是物理地址
  内核告诉 MMU 如何将每个虚拟地址映射到物理地址
    MMU 本质上有一个表，由 va 索引，产生 pa
    称为“页表”
  MMU 可以限制用户代码可以使用的虚拟地址

* x86 映射 4 KB “页面”
  并对齐 - 从 4 KB 边界开始
  因此页表索引是 VA 的前 20 位

*页表条目（PTE）中有什么？
  见[讲义](x86_translation_and_registers.pdf)
  前 20 位是物理地址的前 20 位
    “物理页码”
    MMU 用 PPN 取代前 20 名 VA
  低 12 位是标志
    存在、可写等

* 页表存储在哪里？
  在 RAM 中——MMU 加载（和存储）PTE
  o/s 可以读/写 PTE

* 页表只是一个 PTE 数组是否合理？
  它有多大？
  2^20 是一百万
  每个条目 32 位
  4 MB 用于整页表——在早期机器上相当大
  小程序会浪费大量内存！
    你只需要几百页的映射
    所以其余的百万个条目将在那里但不需要

* x86 使用“两级页表”来节省空间
  图表
  RAM 中的 PTE 页
  RAM 中的页目录 (PD)
  PDE 还包含 20 位 PPN——1024 个 PTE 指向的页面
  1024 个 PDE 指向 PTE 页
    每个 PTE 页面有 1024 个 PTE——所以总共 1024*1024 个 PTE
  PD 条目可能无效
    那些 PTE 页面不需要存在
    所以小地址空间的页表可以很小

* mmu 如何知道页表在 RAM 中的位置？
  %cr3 保存 PD 的 物理 地址
  PD 持有 PTE 页面的 物理 地址
  它们可以在 RAM 中的任何位置——不必是连续的

* x86 分页硬件如何转换 va？
  需要找到合适的 PTE
  %cr3 指向 PD 的 PA
  前 10 位索引 PD 以获得 PT 的 PA
  下一个 10 位索引 PT 以获得 PTE
  PTE 的 PPN + VA 的低 12

* PTE 中的标志
  P、W、U
  xv6 使用 U 来禁止用户使用内核内存

* 如果 P 位未设置怎么办？或存储和 W 位未设置？
  “页面错误”
  CPU 保存寄存器，强制转移到内核
  xv6 源中的 trap.c
  内核只会产生错误，杀死进程
  或者内核可以安装一个PTE，恢复进程
    例如在从磁盘加载内存页面之后

* 问：为什么是映射而不是例如基/绑定？
  间接允许分页硬件解决许多问题
  例如避免碎片化
  例如写时复制叉
  例如懒惰分配
  
* 问：为什么在内核中使用虚拟内存？
  为用户进程提供页表显然是件好事
  但是为什么有一个内核页表呢？
    内核可以只使用物理地址运行吗？
  答案：是
    Singularity 是一个使用 phys 地址的示例内核
  但是，大多数标准内核确实使用虚拟地址？
  为什么标准内核会这样做？
  - 好处：可以方便内核使用页表/页目录用户地址
    考虑即使是内核代码读写，那么硬件mmu也会对其进行地址转换，那么访问页表的虚拟地址的传入就非常有用，比如系统调用的时候
    但是，这可能是个坏主意：内核/应用程序之间的隔离不佳
  - 好处：内核必须在各种硬件上运行
    它们可能有不同的物理内存布局
