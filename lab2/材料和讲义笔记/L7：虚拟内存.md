第7讲：使用虚拟内存
==

* 计划：你可以用 vm 做的很酷的事情
  - 更好的性能/效率
    例如，一页填零
	  例如，写时复制叉
  - 新功能
    例如，内存映射文件
  - JOS 和虚拟机
  - 本次讲座可能会为最后一个实验室（最终项目）产生想法
  

<!--
  隔离：带墙的图片

  返回用户空间，直到我们遇到第一个系统调用
    然后切换到日期作业
	
  日期系统调用作业
    指出一些墙：
	  U/K 位
        用户不能执行特权指令
		用户只能通过系统调用进入内核
	    只有内核可以加载 cr3
	  页表
	    内核页面上没有 U 位
	  但也分享一下：
	    内核可以读/写用户内存
	    需要内核检查系统调用的参数
-->

* 虚拟内存：几个视图
  * 主要目的：隔离
    每个进程都有自己的地址空间
  * 虚拟内存提供了一个间接级别
    为内核提供了做很酷的事情的机会

* 懒惰/按需页面分配
  * sbrk() 是老式的；
    它要求应用程序“预测”他们需要多少内存
	  应用程序很难提前预测他们需要多少内存
	  sbrk 分配可能永远不会使用的内存。
    *现代操作系统懒惰地分配内存
    在应用程序需要时分配物理内存
  * 硬件解决方案
    <!---
	  绘制地址空间的 xv6 用户部分 
	  演示解决方案；trap.c 中映射页面之前的断点
      解释页面错误
	  -->

<!--
	xv6 内存布局讨论
	
  用户虚拟地址从零开始
    当然用户 va 0 映射到每个进程的不同 pa
  2GB 用于用户堆连续增长
    但不需要有连续的物理内存——没有碎片问题
  内核和用户映射——易于切换系统调用、中断
  内核映射到所有进程的同一位置
    简化进程之间的切换
  内核易于读写用户内存
    使用用户地址，例如 sys 调用参数
  内核易于读写物理内存
    pa x 映射到 va x+0x80000000
    我们很快就会在操作页表时看到这一点
	
  跛脚部分：用户堆栈
    还有，initcode 和 date（不同的 AS 布局）
	但方便检查地址是否有效（va < p->size）
	
  为什么内核使用vm？
-->

* 退后一步：班级视角
  - 没有一种设计操作系统的最佳方式
    许多操作系统使用 VM，但您不必
  - Xv6 和 JOS 展示了操作系统设计的例子
    他们缺乏复杂设计的许多特征
    事实上，与真正的操作系统相比，它们相当蹩脚
	  然而，仍然相当复杂
  - 我们的目标：教您关键思想，以便您可以推断
    Xv6 和 JOS 是暴露关键思想的最小设计
	  你应该能够让他们变得更好
	  您应该能够深入了解 Linux 并找到自己的方式

* 保护页面以防止堆栈溢出
  * 在用户堆栈下方放置一个非映射页面
    如果堆栈溢出，应用程序将看到页面错误
  * 当应用程序脱离堆栈进入保护页面时分配更多堆栈 
    <!---
	  绘制地址空间的 xv6 用户部分 
      用 -O 编译，这样编译器就不会优化尾递归
	  演示堆栈溢出 
        在 g 处设置断点
  	    运行堆栈溢出 
	    看看 $esp
	    在 qemu 控制台查看 pg 信息
	    笔记页没有 U 位
	  -->

* 一页填零
  * 内核经常用零填充一个页面
  * 想法：memset *one* 页面为零
    当内核需要零填充页面时映射该页面写时复制
    在写入时复制页面并将其映射到应用程序地址空间中的读/写

* 在 xv6 中共享内核页表
  *观察：
    kvmalloc() 为每个进程的内核页表分配新页
    但所有进程都有相同的内核页表
  * 思路：修改kvmalloc()/freevm()共享内核页表
    <!---
	  演示 HWKVM
	  -->

* 写时复制叉
  *观察：
    xv6 fork 从父级复制所有页面（参见 fork()）
    但是 fork 通常紧跟在 exec 之后
  * 想法：在父子之间共享地址空间
    修改 fork() 以映射页面 copy-on-write（在 PTE 和 PDE 中使用额外的可用系统位）
    在页面错误时，复制页面并将其映射为读/写

* 需求分页
  * 观察：exec 将完整文件加载到内存中（参见 exec.c）
    昂贵：这样做需要时间（例如，文件存储在慢速磁盘上）
    不必要：可能不会使用整个文件
  * 想法：按需从文件加载页面
    分配页表条目，但按需标记它们
    出错时，从文件中读入页面并更新页表条目
  * 挑战：文件大于物理内存（见下一个想法）

* 使用比物理内存大的虚拟内存
  *观察：应用程序可能需要比物理内存更多的内存
  * 想法：在磁盘上存储地址空间中不常用的部分
    地址空间的页入页和页出页透明
  * 当工作集适合物理内存时工作

* 内存映射文件
  * 想法：允许使用加载和存储访问文件
    可以轻松读写文件的一部分
    例如，不必使用 lseek 系统调用更改偏移量
  * 按需调入文件页面
    当内存已满时，将不经常使用的文件页面调出

* 共享虚拟内存
  * 想法：允许不同机器上的进程共享虚拟内存
    给人一种通过网络共享物理内存的错觉
  * 复制只读的页面
  * 在写入时使副本无效
  
* JOS 和虚拟内存
  * 布局：[图片](l-josmem.html)

  * UVPT 技巧（实验 4）
    在 0x3BD 处递归映射 PD
      PD的虚拟地址为(0x3BD<<22)|(0x3BD<<12)
    如果我们想找到虚拟页面 n 的 pte，计算
		pde_t uvpt[n]，其中 uvpt 是 (0x3BD << 22) 
        = uvpt + n * 4（因为 pdt 是一个词）
	    = (0x3BD << 22) | (n 的前 10 位) | （n 的底部 10 位）<< 2
		= 10 | 10 | 12
    例如，uvpt[0] 是地址 (0x3BD << 22)，按照指针给我们
	  页目录中的第一个条目，它指向第一个页表，它
	  我们用 0 索引，这给了我们 pte 0

    比 pgdirwalk() 更简单？
    
  * 用户级写时复制叉（lab4）
    JOS 将页面错误传播到用户空间
    用户程序可以玩与内核类似的 VM 技巧！
    你会做用户级的写时复制叉