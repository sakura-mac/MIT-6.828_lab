https://pdos.csail.mit.edu/6.828/2017/labs/lab5/

# 实验 5：文件系统、Spawn 和 Shell

## 介绍

在本实验中，您将实现`spawn`，一个加载和运行磁盘可执行文件的库调用。然后，您将充实您的内核和库操作系统，足以在控制台上运行 shell。这些特性需要一个文件系统，本实验介绍了一个简单的读/写文件系统。

### 入门

使用 Git 获取最新版本的课程存储库，然后基于我们的 lab5 分支`origin/lab5`创建一个名为`lab5`的本地分支：``

```
雅典娜%cd ~/6.828/lab
雅典娜%add git
雅典娜%git pull
已经是最新的。
雅典娜% git checkout -b lab5 origin/lab5
分支 lab5 设置为跟踪远程分支 refs/remotes/origin/lab5。
切换到新分支“lab5”
雅典娜% git merge lab4
通过递归进行合并。
.....
雅典娜% 
```

实验室这部分的主要新组件是文件系统环境，位于新的`fs`目录中。浏览此目录中的所有文件以了解所有新内容。此外，在`user`和`lib`目录中有一些新的文件系统相关的源文件，

| `fs/fs.c`        | mainipulates 文件系统的磁盘结构的代码。                  |
| ---------------- | -------------------------------------------------------- |
| `fs/bc.c`        | 一个简单的块缓存建立在我们的用户级页面错误处理设施之上。 |
| `文件系统/ide.c` | 最小的基于 PIO（非中断驱动）的 IDE 驱动程序代码。        |
| `fs/serv.c`      | 使用文件系统 IPC 与客户端环境交互的文件系统服务器。      |
| `库/fd.c`        | 实现通用类 UNIX 文件描述符接口的代码。                   |
| `库/文件.c`      | 磁盘文件类型的驱动程序，作为文件系统 IPC 客户端实现。    |
| `库/控制台.c`    | 控制台输入/输出文件类型的驱动程序。                      |
| `库/ spawn.c`    | `spawn`库调用的代码框架。                                |

在合并新的实验 5 代码后，您应该再次运行实验 4 中的 pingpong、primes 和 forktree 测试用例。您将需要注释掉`kern/init.c 中`的`ENV_CREATE(fs_fs)`行， 因为`fs/fs.c`尝试执行一些 JOS 还不允许的 I/O。同样，暂时注释掉调用中 `的lib / exit.c中`; 此函数调用您将在实验室稍后实现的子例程，因此如果调用它会发生恐慌。如果您的实验室 4 代码不包含任何错误，则测试用例应该可以正常运行。在他们工作之前不要继续。开始练习 1 时，不要忘记取消注释这些行。 `````close_all()```

如果它们不起作用，请使用 git diff lab4检查所有更改，确保没有您为 lab4（或之前）编写的任何代码在 lab 5 中丢失。确保 lab 4 仍然有效。

### 实验室要求

和以前一样，您需要完成实验室中描述的所有常规练习和*至少一个*挑战题。此外，您需要写下对实验室中提出的问题的简短回答，并简短（例如，一段或两段）描述您为解决所选挑战问题所做的工作。如果你实现了多个挑战问题，你只需要在文章中描述其中一个，当然欢迎你做更多。在提交您的工作之前，将`撰写`的内容放在`lab5`目录顶层的名为`answers-lab5.txt`的文件中。``

# 文件系统预习

您将使用的文件系统比包括 xv6 UNIX 在内的大多数“真实”文件系统要简单得多，但它的功能强大到足以提供基本功能：创建、读取、写入和删除以分层目录结构组织的文件。

我们（无论如何）目前只开发一个单用户操作系统，它提供的保护足以捕获错误，但不能保护多个相互可疑的用户相互隔离。因此，我们的文件系统不支持文件所有权或权限的 UNIX 概念。我们的文件系统目前也不像大多数 UNIX 文件系统那样支持硬链接、符号链接、时间戳或特殊设备文件。

## 磁盘文件系统结构

大多数 UNIX 文件系统将可用磁盘空间划分为两种主要类型的区域： *inode*区域和*数据*区域。UNIX 文件系统为文件系统中的每个文件分配一个*inode*；文件的 inode 保存有关文件的关键元数据，例如其`stat`属性和指向其数据块的指针。数据区域被划分为更大（通常为 8KB 或更多）的 *数据块*，文件系统在其中存储文件数据和目录元数据。目录条目包含文件名和指向 inode 的指针；文件被称为*硬链接* 如果文件系统中的多个目录条目引用该文件的 inode。由于我们的文件系统不支持硬链接，因此我们不需要这种间接级别，因此可以进行方便的简化：我们的文件系统根本不会使用 inode，而是简单地存储所有文件（或子目录）描述该文件的（一个且唯一的）目录条目中的元数据。

文件和目录在逻辑上都由一系列数据块组成，这些数据块可能分散在整个磁盘中，就像环境虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了用于读取和写入文件内任意偏移量的字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统确实允许用户环境直接*读取*目录元数据（例如，使用`read`），这意味着用户环境可以自己执行目录扫描操作（例如，实现`ls`程序），而不必依赖对文件系统的额外特殊调用。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，从而很难在不改变或至少改变文件系统的内部布局的情况下重新编译应用程序也是如此。



### 扇区和块

大多数磁盘不能以字节粒度进行读写，而是以*扇区*为单位进行读写。在 JOS 中，扇区是每个 512 字节。文件系统实际上以*块*为单位分配和使用磁盘存储。注意这两个术语之间的区别： *扇区大小*是磁盘硬件的属性，而*块大小*是使用磁盘的操作系统的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。

UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间变得更便宜，并且以更大的粒度管理存储更有效。我们的文件系统将使用 4096 字节的块大小，方便地匹配处理器的页面大小。

### 超级块

![磁盘布局](https://pdos.csail.mit.edu/6.828/2017/labs/lab5/disk.png)

文件系统通常在磁盘上“易于查找”的位置（例如开头或结尾）保留某些磁盘块，以保存描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次挂载的时间、文件系统上次检查错误的时间等。这些特殊块称为*超级块*。

我们的文件系统将只有一个超级块，它始终位于磁盘上的块 1。它的布局是通过定义`struct Super`在`INC / fs.h文件`。块 0 通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，在磁盘的多个间隔很宽的区域中复制，因此如果其中一个被损坏或磁盘在该区域出现介质错误，则仍然可以找到其他超级块并用于访问文件系统。

### 文件元数据

![文件结构](https://pdos.csail.mit.edu/6.828/2017/labs/lab5/file.png)在我们的文件系统中描述文件的元数据的布局`struct File`在`inc/fs.h 中`描述。此元数据包括文件的名称、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有 inode，因此此元数据存储在磁盘上的目录条目中。与大多数“真实”文件系统不同，为简单起见，我们将使用这种`File`结构来表示出现在*磁盘和内存中的*文件元数据 。



该`f_direct`阵列`struct File`包含的空间来存储前10个（块号`NDIRECT`文件）块，我们称之为文件的*直接*块。对于大小不超过 10*4096 = 40KB 的小文件，这意味着所有文件块的块号将直接适合`File`结构本身。然而，对于较大的文件，我们需要一个地方来保存文件的其余块编号。因此，对于大小超过 40KB 的任何文件，我们分配一个额外的磁盘块，称为文件的*间接块*，以容纳多达 4096/4 = 1024 个额外的块号。因此，我们的文件系统允许文件最大为 1034 个块，或略高于 4 兆字节。为了支持更大的文件，“真正的”文件系统通常支持 *双重*和*三重间接块*也是如此。

### 目录与常规文件

一个`File`在我们的文件系统结构可以表示一个*普通*文件或目录; 这两种类型的“文件”通过结构中的`type`字段来区分`File`。文件系统以完全相同的方式管理常规文件和目录文件，除了它根本不解释与常规文件关联的数据块的内容，而文件系统将目录文件的内容解释为一系列`File`描述目录中文件和子目录的结构。



我们文件系统中的超级块包含一个`File`结构（中的`root`字段`struct Super`），其中包含文件系统根目录的元数据。该目录文件的内容是`File`描述位于文件系统根目录中的文件和目录的结构序列。根目录中的任何子目录又可能包含更多`File`表示子子目录的结构，依此类推。

# 文件系统

本实验的目标不是让您实现整个文件系统，而是让您只实现某些关键组件。特别是，您将负责将块读入块缓存并将它们刷新回磁盘；分配磁盘块；将文件偏移量映射到磁盘块；并在IPC接口中实现读、写和打开。因为您不会自己实现所有的文件系统，所以熟悉所提供的代码和各种文件系统接口非常重要。

## 磁盘访问

我们操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在我们的内核中实现任何磁盘访问功能。我们没有采用传统的“单体”操作系统策略，即向内核添加 IDE 磁盘驱动程序以及必要的系统调用以允许文件系统访问它，而是将 IDE 磁盘驱动程序实现为用户级文件的一部分系统环境。我们仍然需要稍微修改内核，以便进行设置，以便文件系统环境具有实现磁盘访问本身所需的权限。

只要我们依靠轮询、基于“程序化 I/O”(PIO) 的磁盘访问并且不使用磁盘中断，就很容易以这种方式在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序（例如，L3 和 L4 内核执行此操作），但由于内核必须现场设备中断并将它们分派到正确的用户模式环境，因此更加困难.

x86 处理器使用 EFLAGS 寄存器中的 IOPL 位来确定是否允许保护模式代码执行特殊的设备 I/O 指令，例如 IN 和 OUT 指令。由于我们需要访问的所有 IDE 磁盘寄存器都位于 x86 的 I/O 空间中而不是内存映射，因此我们唯一需要为文件系统环境提供“I/O 特权”允许文件系统访问这些寄存器。实际上，EFLAGS 寄存器中的 IOPL 位为内核提供了一种简单的“全有或全无”方法来控制用户模式代码是否可以访问 I/O 空间。在我们的例子中，我们希望文件系统环境能够访问 I/O 空间，但我们根本不希望任何其他环境能够访问 I/O 空间。

**练习 1.** `i386_init`通过将类型传递`ENV_TYPE_FS`给您的环境创建函数来识别文件系统环境`env_create`。`env_create`在`env.c 中进行`修改，使其赋予文件系统环境 I/O 特权，但永远不会将该特权赋予任何其他环境。

确保您可以启动文件环境而不会导致常规保护错误。您应该通过make grade.

**题**

1. 当您随后从一种环境切换到另一种环境时，您是否需要做任何其他事情来确保此 I/O 权限设置得到正确保存和恢复？为什么？



请注意，本实验中的`GNUmakefile`文件将 QEMU 设置为使用文件`obj/kern/kernel.img` 作为磁盘 0（在 DOS/Windows 下通常为“驱动器 C”）的映像，并使用（新）文件`obj/fs/fs.img` 作为磁盘 1（“驱动器 D”）的映像。在本实验中，我们的文件系统应该只接触磁盘 1；磁盘 0 仅用于引导内核。如果您设法以某种方式损坏了任一磁盘映像，只需键入以下内容，即可将它们都重置为原始的“原始”版本：

```
$ rm obj/kern/kernel.img obj/fs/fs.img
$make
```

或通过做：

```
$ make clean
$make
```

*挑战！* 使用或不使用 DMA 实现中断驱动的 IDE 磁盘访问。您可以决定是否将设备驱动程序移动到内核中，将其与文件系统一起保留在用户空间中，或者甚至（如果您真的想进入微内核精神）将其移动到它自己的单独环境中。

## 块缓存

在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“缓冲区缓存”（实际上只是一个块缓存）。块缓存的代码在`fs/bc.c 中`。

我们的文件系统将仅限于处理 3GB 或更小的磁盘。我们保留了文件系统环境地址空间的一个大的、固定的 3GB 区域，从 0x10000000 ( `DISKMAP`) 到 0xD0000000 ( `DISKMAP+DISKMAX`)，作为磁盘的“内存映射”版本。例如，磁盘块 0 映射到虚拟地址 0x10000000，磁盘块 1 映射到虚拟地址 0x10001000，依此类推。`fs/bc.c 中`的`diskaddr`函数 实现了从磁盘块号到虚拟地址的转换（以及一些完整性检查）。``

由于我们的文件系统环境有自己的虚拟地址空间，独立于系统中所有其他环境的虚拟地址空间，而且文件系统环境唯一需要做的就是实现文件访问，所以保留大部分文件系统环境的地址空间以这种方式。由于现代磁盘大于 3GB，因此在 32 位机器上执行真正的文件系统实现会很尴尬。这种缓冲区缓存管理方法在具有 64 位地址空间的机器上可能仍然是合理的。

当然，将整个磁盘读入内存需要很长时间，所以我们将实现一种形式的*需求分页*，我们只在磁盘映射区域分配页面，并从磁盘中读取相应的块响应此区域中的页面错误。这样，我们就可以假装整个磁盘都在内存中。

**练习 2.** 实现`fs/bc.c 中`的`bc_pgfault`和`flush_block` 函数。 是一个页面错误处理程序，就像您在上一个实验室中为写时复制 fork 编写的处理程序一样，除了它的工作是从磁盘加载页面以响应页面错误。编写此内容时，请记住 (1) 可能不会与块边界对齐，并且 (2) 在扇区中操作，而不是在块中操作。 ```bc_pgfault``addr``ide_read`

*如有必要，* 该`flush_block`函数应将块写入磁盘 。 如果块甚至不在块缓存中（即页面未映射）或者它不脏，则不应执行任何操作。我们将使用 VM 硬件来跟踪磁盘块自上次从磁盘读取或写入磁盘后是否已被修改。要查看块是否需要写入，我们可以查看条目中是否设置了“脏”位。（该位由处理器设置以响应对该页的写入；请参阅386 参考手册[第 5 章](http://pdos.csail.mit.edu/6.828/2011/readings/i386/s05_02.htm)中的5.2.4.3 。）将块写入磁盘后，应使用清除该位。 `flush_block``PTE_D``uvpt``PTE_D``flush_block``PTE_D``sys_page_map`

使用make grade来测试你的代码。您的代码应该通过“check_bc”、“check_super”和“check_bitmap”。

```
fs/fs.c 中` 的`fs_init`函数是如何使用块缓存的主要示例。初始化块缓存后，它只是将指针存储到全局变量中的磁盘映射区域中 。在这之后，我们可以简单地从 结构中读取，就好像它们在内存中一样，我们的页面错误处理程序将根据需要从磁盘读取它们。 ```super``super
```

*挑战！* 块缓存没有逐出策略。一旦一个块出现故障，它就永远不会被删除，并将永远留在内存中。将逐出添加到缓冲区缓存。使用`PTE_A` 页表中的“已访问”位（硬件在对页面的任何访问时设置这些位），您可以跟踪磁盘块的大致使用情况，而无需修改访问磁盘映射区域的代码中的每个位置。小心脏块。

## 块位图

后`fs_init`套`bitmap`指针，我们可以把`bitmap`称为比特的填充阵列，一个用于在磁盘上的每个块。例如，参见 ，`block_is_free`它只是检查给定块在位图中是否标记为空闲。

**练习3.** 使用`free_block`作为一种模式来实现`alloc_block`的`FS / fs.c`，应在该位图找到一个免费的磁盘块，将其标记使用，并返回该块的数量。分配块时，应立即使用 将更改的位图块刷新到磁盘`flush_block`，以帮助文件系统一致性。

使用make grade来测试你的代码。您的代码现在应该通过“alloc_block”。

## 文件操作

我们在`fs/fs.c 中`提供了多种函数 来实现解释和管理`File`结构、扫描和管理目录文件的条目以及从根遍历文件系统以解析绝对路径名所需的基本工具. 通读`fs/fs.c 中的`*所有*代码， 并确保在继续之前了解每个函数的作用。``

**练习 4.** 实施 `file_block_walk` 和`file_get_block`。 `file_block_walk`从文件中的块偏移量映射到该块`struct File`或间接块中该块的指针， `pgdir_walk`与页表所做的非常相似 。 `file_get_block`更进一步，映射到实际的磁盘块，必要时分配一个新的。

使用make grade来测试你的代码。您的代码应该通过“file_open”、“file_get_block”、“file_flush/file_truncated/file rewrite”和“testfile”。

`file_block_walk`并且`file_get_block`是文件系统的主力。例如，`file_read` 并且`file_write`是小比簿记顶上更 `file_get_block`需要复制散射块和连续缓冲区之间的字节。

*挑战！* 如果文件系统在操作过程中被中断（例如，由于崩溃或重新启动），则文件系统可能会损坏。实施软更新或日志记录以使文件系统具有崩溃恢复能力，并演示旧文件系统会损坏的某些情况，但您的不会。

## 文件系统界面

现在我们在文件系统环境中拥有了必要的功能，我们必须让其他希望使用文件系统的环境可以访问它。由于其他环境无法直接调用文件系统环境中的函数，我们将通过构建在 JOS 的 IPC 机制之上的*远程过程调用*或 RPC 抽象公开对文件系统环境的访问。从图形上看，这是对文件系统服务器的调用（例如，读取）的样子

```
      常规环境 FS 环境   +--------------+ +--------------+   | 阅读 | | 文件读取|   | (lib/fd.c) | | (fs/fs.c) | ...|.......|.......|...|.......^.......|......... .....   | v | | | | RPC机制   | devfile_read | | 服务阅读|   | (lib/file.c) | | (fs/serv.c) |   | | | | ^ |   | v | | | |   | fsipc | | 服务 |   | (lib/file.c) | | (fs/serv.c) |   | | | | ^ |   | v | | | |   | ipc_send | | ipc_recv |   | | | | ^ |   +-------|-------+ +-------|-------+           | |           +--------------------+ 
```

虚线下方的所有内容只是从常规环境到文件系统环境获取读取请求的机制。从一开始，`read`（我们提供的）适用于任何文件描述符，并简单地分派到适当的设备读取函数，在这种情况下 `devfile_read`（我们可以有更多的设备类型，如管道）。 `devfile_read` 工具`read`专门针对磁盘上的文件。这个`devfile_*`函数和`lib/file.c 中`的其他函数 实现了 FS 操作的客户端，并且都以大致相同的方式工作，将参数捆绑在一个请求结构中，调用 `fsipc`发送 IPC 请求，解包并返回结果。这`fsipc` 函数只是处理向服务器发送请求和接收回复的常见细节。

文件系统服务器代码可以在`fs/serv.c 中`找到。它在`serve`函数中循环，通过 IPC 无休止地接收请求，将该请求分派给适当的处理函数，并通过 IPC 将结果发送回。在读取示例中， `serve`将调度到`serve_read`，它将处理特定于读取请求的 IPC 详细信息，例如解包请求结构并最终调用 `file_read`以实际执行文件读取。

回想一下，JOS 的 IPC 机制允许环境发送单个 32 位数字，并且可以选择共享页面。要将请求从客户端发送到服务器，我们使用 32 位数字作为请求类型（文件系统服务器 RPC 已编号，就像系统调用的编号方式一样）并将请求的参数存储`union Fsipc`在页面上的a 中 通过 IPC 共享。在客户端，我们总是在`fsipcbuf`; 在服务器端，我们将传入的请求页面映射到`fsreq` ( `0x0ffff000`)。

服务器还通过 IPC 发回响应。我们使用 32 位数字作为函数的返回码。对于大多数 RPC，这就是它们返回的全部内容。 `FSREQ_READ`并`FSREQ_STAT`返回数据，它们只是将数据写入客户端发送请求的页面。不需要在响应 IPC 中发送此页面，因为客户端首先与文件系统服务器共享它。此外，在其响应中，`FSREQ_OPEN`与客户端共享一个新的“Fd 页面”。我们将很快返回到文件描述符页面。

**练习5** 实现`serve_read`在`FS / serv.c`。

`serve_read`的繁重工作将由已经`file_read`在`fs/fs.c 中实现的` （反过来，它只是一堆对 的调用 `file_get_block`）来完成。 `serve_read`只需要提供用于文件读取的RPC接口。查看注释和代码`serve_set_size`以大致了解服务器功能的结构。

使用make grade来测试你的代码。您的代码应通过“serve_open/file_stat/file_close”和“file_read”以获得 70/150 的分数。

**练习6.** 实现`serve_write`在`FS / serv.c`和 `devfile_write`在`LIB / file.c`。

使用make grade来测试你的代码。您的代码应该通过“file_write”、“file_read after file_write”、“open”和“large file”以获得 90/150 的分数。

# 产卵过程

我们已经为您提供了`spawn`（参见`lib/spawn.c`） 的代码， 它创建一个新环境，将文件系统中的程序映像加载到其中，然后启动运行该程序的子环境。然后父进程独立于子进程继续运行。该`spawn`函数的作用类似于`fork`UNIX 中的 a 后跟`exec`子进程中的立即数。

我们实现`spawn`而不是 UNIX 风格，`exec`因为`spawn`更容易以“外内核方式”从用户空间实现，无需内核的特殊帮助。想想为了`exec`在用户空间中实现你必须做什么，并确保你明白为什么它更难。

**练习 7.** `spawn`依靠新的系统调用 `sys_env_set_trapframe`来初始化新创建环境的状态。`sys_env_set_trapframe`在`kern/syscall.c 中`实现 （不要忘记在 中调度新的系统调用`syscall()`）。

通过运行`kern/init.c 中`的`user/spawnhello`程序来测试您的代码，该 程序将尝试从文件系统中生成`/hello`。````

使用make grade来测试你的代码。

*挑战！* 实现 Unix 风格的`exec`.

*挑战！* 实现`mmap`-style 内存映射文件，并`spawn`在可能的情况下修改为直接从 ELF 映像映射页面。

## 跨 fork 和 spawn 共享库状态

UNIX 文件描述符是一个通用概念，还包括管道、控制台 I/O 等。在 JOS 中，这些设备类型中的每一种都有一个对应的`struct Dev`，带有指向实现读/写/等功能的指针。对于该设备类型。 `lib/fd.c`在此`之上`实现了通用的类 UNIX 文件描述符接口。每个都 `struct Fd`指示其设备类型，并且`lib/fd.c 中的`大多数函数只是将操作分派到适当的`struct Dev`.

`lib/fd.c`还在 每个应用程序环境的地址空间中维护*文件描述符表*区域，从 `FDTABLE`. 该区域`MAXFD`为应用程序可以同时打开的最多（当前为 32 个）文件描述符中的每一个保留一个页面价值 (4KB) 的地址空间。在任何给定时间，当且仅当相应的文件描述符正在使用中时，才会映射特定的文件描述符表页面。每个文件描述符在从 开始的区域中还有一个可选的“数据页面” `FILEDATA`，设备可以选择使用这些页面。

我们想在`fork`和之间共享文件描述符状态 `spawn`，但文件描述符状态保存在用户空间内存中。现在， on `fork`，内存将被标记为 copy-on-write，因此状态将被复制而不是共享。（这意味着环境将无法在它们自己没有打开的文件中查找，并且管道无法跨分支工作。） On `spawn`，内存将被留下，根本不会被复制。（实际上，生成的环境从没有打开的文件描述符开始。）

我们将更改`fork`以了解某些内存区域由“库操作系统”使用并且应始终共享。我们不是在某处硬编码区域列表，而是在页表条目中设置一个其他未使用的位（就像我们对 中的`PTE_COW`位所做的那样`fork`）。

我们`PTE_SHARE`在`inc/lib.h 中`定义了一个新位。该位是 Intel 和 AMD 手册中标记为“可供软件使用”的三个 PTE 位之一。我们将建立约定，如果页表条目设置了该位，则 PTE 应该在`fork`和 中直接从父级复制到子级`spawn`。请注意，这与将其标记为写时复制不同：如第一段所述，我们希望确保*共享* 对页面的更新。

**锻炼8.** 变化`duppage`中`的lib / fork.c`遵循新的约定。如果页表条目`PTE_SHARE` 设置了位，则直接复制映射。（您应该使用`PTE_SYSCALL`, not`0xfff`来屏蔽页表条目中的相关位。也可以`0xfff` 获取访问过的位和脏位。）

同样，`copy_shared_pages`在 `lib/spawn.c 中实现`。它应该遍历当前进程中的所有页表条目（就像`fork` 之前所做的那样），将任何`PTE_SHARE`设置了该位的页映射复制 到子进程中。

使用make run-testpteshare来检查你的代码是否正确行为。您应该会看到写着“ `fork handles PTE_SHARE right` ”和“ `spawn handles PTE_SHARE right` ”的行。

使用make run-testfdsharing检查文件描述符正确共享。您应该会看到写着“ `read in child successfully` ”和“ `read in parent successfully` ”的行。

# 键盘接口

为了让 shell 工作，我们需要一种方法来输入它。QEMU 一直在显示我们写入 CGA 显示器和串行端口的输出，但到目前为止我们只在内核监视器中获取输入。在 QEMU 中，在图形窗口中输入的输入显示为从键盘输入到 JOS，而输入到控制台的输入显示为串行端口上的字符。 `kern/console.c`已经包含自实验 1 以来内核监视器使用的键盘和串行驱动程序，但现在您需要将它们附加到系统的其余部分。

**练习 9.** 在您的`kern/trap.c 中`，调用`kbd_intr`处理陷阱 `IRQ_OFFSET+IRQ_KBD`和`serial_intr`处理陷阱`IRQ_OFFSET+IRQ_SERIAL`。

我们在`lib/console.c 中`为您实现了控制台输入/输出文件类型。`kbd_intr`并`serial_intr` 在控制台文件类型耗尽缓冲区时用最近读取的输入填充缓冲区（控制台文件类型默认用于 stdin/stdout，除非用户重定向它们）。

通过运行make run-testkbd并键入几行来测试您的代码。当您完成它们时，系统应该将您的台词回显给您。尝试在控制台和图形窗口中输入，如果两者都可用的话。

# Shell

运行make run-icode或make run-icode-nox。这将运行您的内核并启动`user/icode`。 `icode` execs `init`，它将控制台设置为文件描述符 0 和 1（标准输入和标准输出）。然后它会生成`sh`，即外壳。您应该能够运行以下命令：

```
	回声你好世界 | 猫
	猫 lorem |猫
	猫 lorem |num
	cat lorem |num |num |num |num |num
	lsfd
```

请注意，用户库例程`cprintf` 直接打印到控制台，而不使用文件描述符代码。这对于调试非常有用，但对于管道到其他程序来说却不是很好。要将输出打印到特定文件描述符（例如，1，标准输出），请使用`fprintf(1, "...", ...)`. `printf("...", ...)`是打印到 FD 1 的`快捷方式。`有关示例，请参见`user/lsfd.c`。

**练习 10。**

shell 不支持 I/O 重定向。运行sh <script而不是像上面那样手动输入脚本中的所有命令会很好 。为 < to 添加 I/O 重定向 `user/sh.c`。

通过sh <script在 shell 中键入内容来测试您的实现

运行make run-testshell以测试您的外壳。 `testshell`只是将上述命令（也可以在`fs/testshell.sh 中`找到 ）输入 shell，然后检查输出是否与`fs/testshell.key`匹配。



*挑战！* 向外壳添加更多功能。可能性包括（一些也需要更改文件系统）：

- 后台命令 ( `ls &`)
- 每行多个命令 ( `ls; echo hi`)
- 命令分组 ( `(ls; echo hi) | cat > out`)
- 环境变量扩展 ( `echo $hello`)
- 引用 ( `echo "a | b"`)
- 命令行历史和/或编辑
- 制表符补全
- 目录、cd 和用于命令查找的 PATH。
- 文件创建
- ctl-c 杀死运行环境

但可以随意做一些不在此列表中的事情。



此时您的代码应该通过所有测试。像往常一样，您可以使用 对您的提交进行评分make grade并使用 make handin。

**这样就完成了实验室。** 像往常一样，不要忘记跑步make grade并写下您的答案和挑战练习解决方案的描述。在提交之前，使用git status和git diff 检查您的更改，不要忘记git add answers-lab5.txt。准备好后，使用 提交您的更改 git commit -am 'my solutions to lab 5'，然后make handin提交您的解决方案。